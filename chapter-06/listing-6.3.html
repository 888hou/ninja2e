<!DOCTYPE html>
<html>

<head>
  <title>Using closures to approximate private variable</title>
  <meta charset="utf-8">
  <script src="../assert.js"></script>
  <link rel="stylesheet" type="text/css" href="../assert.css">
</head>

<body>
	<script>
    function Ninja() {                                  	//#A
      var feints = 0;                                        //#B
      this.getFeints = function(){                       	//#C
        return feints;                   			//#C
      };                                                 	//#C
      this.feint = function(){                           	//#D
        feints++;                  				//#D
      };                                                 	//#D
     }

     var ninja1 = new Ninja();                              	    //#E
     ninja1.feint();                                            //#F

     assert(ninja1.feints === undefined,                        //#G
            "And the private data is inaccessible to us.");     //#G
     assert(ninja1.getFeints() == 1,                            //#H
           "We're able to access the internal feint count.");  //#H


     var ninja2 = new Ninja();					    	   //#I
     assert(ninja2.getFeints() == 0,                                   //#I
            "The second ninja object gets it’s own feints variable."); //#I

    //#A Defines the constructor for a Ninja.
    //#B Declares a variable inside the constructor function. Because the scope of the variable is limited to inside the constructor, it’s a “private” variable. We’ll use it to count how many times the ninja has feinted.
    //#C Creates an accessor method for the feints counter. As the variable is not accessible to code outside the constructor, this is a common way to give read-only access to the value.
    //#D Declares the increment method for the value. Because the value is private, no one can screw it up behind our backs; they are limited to the access that we give them via methods.
    //#E Now for testing; first we construct an instance of Ninja.
    //#F Calls the feint method, which increments the count of the number of times that our ninja has feinted.
    //#G Verifies that we can’t get at the variable directly.
    //#H Shows that we’ve caused the value to increment to 1, even though we had no direct access to it. We can affect the feints value because, even though the constructor in which it’s declared has finished executing and gone out of scope, the feints variable is bound into the closure (think protective bubble) created by the definition of the feint method, and is available to that method.
    //#I When we create a new ninja2 object with the Ninja constructor, the ninja2 objects gets its own feints variable
	</script>
</body>
</html>
